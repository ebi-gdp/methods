---
title: "Polygenic risk score effect sizes"
---

<details>

<summary>Metrics explanation</summary>

<dl>

<dt>AUC</dt>

<dd>Area Under Receiver Operating Characteristic</dd>

<dd>This metric cares only about relative ordering of observations, and is available only for binary traits.</dd>

<dt>β</dt>

<dd>Standardized regression coefficients. For continuous traits, this is the change in the trait (in standard deviations) per standard deviation of the PGS. For binary traits, this is the change in the log-odds per standard deviation of the PGS.</dd>

<dd>This is the metric that was used for meta-analyses.</dd>

<dt>Odds Ratio (OR)</dt>

<dd>This is the change in the odds ratio per standard deviation of the PGS (exp(β))</dd>

<dt>R²</dt>

<dd>This is the variance explained by the PGS on the observed scale for continuous traits, or on the liability scale for binary traits</dd>

</dl>

</details>

This interactive plot corresponds to Figure 2A and Supplementary Figures 1-5 in the published article.

```{ojs setup}
//| echo: false

import { aq, op } from '@uwdata/arquero'

d3 = require('d3')

async function* fetchPaginatedData(baseUrl, paramName, paramValue) {
  const results = [];
  let hasMore = true;
  let url = new URL(baseUrl);

  // Set the single query parameter
  url.searchParams.set(paramName, paramValue);

  while (hasMore) {
    try {
      const response = await d3.json(url.toString());

      if (response && response.results) {
        results.push(...response.results);
        yield results;

        if (response.next) {
          hasMore = true;
          url = new URL(response.next);
        } else {
          hasMore = false;
        }
      } else {
        hasMore = false;
      }
    } catch (error) {
      console.error("Error fetching data:", error);
      hasMore = false;
    }
  }
}
```

```{ojs}
//| echo: false

// parse performance metrics here into a consistent structure
performanceResults = fetchPaginatedData(
  "https://www.pgscatalog.org/rest/performance/search",
  "pgp_id",
  "PGP000517"
);

raw_metrics = aq.from(performanceResults)
  .select("id", "associated_pgs_id", "sampleset", "performance_metrics")
  .derive({
    cohort_name_full: d => d.sampleset.samples[0].cohorts[0].name_full,
    cohort_name_short: d => d.sampleset.samples[0].cohorts[0].name_short,
    ancestry: d=> d.sampleset.samples[0].ancestry_broad,
    effect_sizes: d=> d.performance_metrics.effect_sizes,
    othermetrics: d=> d.performance_metrics.othermetrics,
    class_acc: d=> d.performance_metrics.class_acc
  })

cols = ["id", "associated_pgs_id", "cohort_name_full", "cohort_name_short", "ancestry", "metric_type", "value", "value_ci_lower", "value_ci_upper"]

effect_sizes = raw_metrics
  .filter(d => op.length(d.effect_sizes) > 0)
  .unroll("effect_sizes")
  .derive({
    metric_type: d=> d.effect_sizes.name_short,
    value: d=> d.effect_sizes.estimate,
    value_ci_lower: d=> d.effect_sizes.ci_lower,
    value_ci_upper: d=> d.effect_sizes.ci_upper
  })
  .select(cols)

othermetrics = raw_metrics
  .filter(d => op.length(d.othermetrics) > 0)
  .unroll("othermetrics")
  .derive({
    metric_type: d => d.othermetrics.name_short,
    value: d=> d.othermetrics.estimate,
    value_ci_lower: d=> d.othermetrics.ci_lower,
    value_ci_upper: d=> d.othermetrics.ci_upper
  })
  .select(cols)
  
class_acc = raw_metrics
  .filter(d => op.length(d.class_acc) > 0)
  .unroll("class_acc")
  .derive({
    metric_type: d => d.class_acc.name_short,
    value: d=> d.class_acc.estimate,
    value_ci_lower: d=> d.class_acc.ci_lower,
    value_ci_upper: d=> d.class_acc.ci_upper
  })
  .select(cols)

plotData = effect_sizes.concat(othermetrics, class_acc)

// TODO: calculate is_continuous from the data
// raw_metrics
// plotData.select("cohort").dedupe()
```


```{ojs}
//| echo: false

// parse score data here including method names and tuning types
scoreResults = fetchPaginatedData(
  "https://www.pgscatalog.org/rest/score/search",
  "pgp_id",
  "PGP000517"
);

// note: method name and tuning type is extracted from the PGS names, which isn't ideal
aq.from(scoreResults)
  .select("id", "name")
  .spread({ name: d => op.split(d.name, '.') }, {as: ["method_name", "tuning_type"], limit: 2})
  
// TODO: UKBB_EnsPGS is always CV
// TODO: recode pt_clump_nested as pt_clump 
```

```{ojs}
//| echo: false
//| panel: sidebar

viewof biobanks = Inputs.checkbox(
  new Map( 
    [["UK Biobank", "ukbb"], ["Estonia Biobank", "ebb"], ["Genes & Health", "gnh"], ["FinnGenn", "finngen"], ["HUNT", "hunt"]]),
  { value: ["ukbb", "ebb", "gnh", "finngen", "hunt"], 
    label: "Biobank:",
    format: ([name, value]) => `${name} (${value})`, 
    sort: true, 
    unique: true }
)

viewof methods = Inputs.checkbox(
  ["dbslmm", "sbayesr", "lassosum", "prscs", "ldpred2", "megaprs", "pt.clump", "UKBB.EnsPRS"],
  { value: ["dbslmm", "sbayesr", "lassosum", "prscs", "ldpred2", "megaprs", "pt.clump", "UKBB.EnsPRS"],
    label: "Method:",
    sort: true, 
    unique: true }
)
```



## Conclusion

Using an ensemble of scores, each created using a different PGS development method, can capture a larger effect size for a phenotype. This means that the strength of the relationship between genetic data and phenotype is greater.
